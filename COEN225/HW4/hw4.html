
<!-- saved from url=(0048)https://www.engr.scu.edu/~slam3/coen225/hw4.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></head><body>Homework 4 (5%) 
<br>
Due: Nov 22, 2022 12am by email, to slam3@scu.edu
<br>
<pre>PROBLEM: Memory Leak Detector

For this homework, you will be implementing a partial function of Valgrind as a shared library called check_leak.so . 

1. Your program will print out a summary of the memory leaks in a C program. 
Ideally, each loss should be noted similar to the --leak-check=full valgrind option:
stack trace, file names and lines (see sample below).
However, you can submit without the stack trace if you are out of time.

2. Your program will also intercept invalid free (such as free after free) calls,
by preventing the free calls after the first valid free, from crashing the program.
Instead, you will show the invalid free attempts at the summary.

The idea of this homework is, we can track each block of memory allocated through malloc(), 
the size, and the location (address and line number) of the function that calls malloc().

A linked list is a natural data structure to track all the allocated chunks.
You are free to add fields to the allocated chunks to chain up chunks for tracking.

At program exit, the total freed count and the total allocated count will be reported.
If the two counts are different, the difference should also be reported as the leak.

For example, this program:

$ cat -n doublefree.c 
     1	#include <stdio.h>
     2	#include <stdlib.h>
     3	#include <stdio.h>
     4	void foo()
     5	{
     6	  void *ptr = malloc(16);
     7	  void *ptr2 = malloc(32);
     8	  free(ptr);
     9	  free(ptr);
    10	}
    11	int main()
    12	{
    13	  void *ptr = malloc(16);
    14	  foo();
    15	}
user@vm-coen225:~/Mini-Valgrind$ gcc -g doublefree.c 
user@vm-coen225:~/Mini-Valgrind$ valgrind --leak-check=full ./a.out
==1518== Memcheck, a memory error detector
==1518== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==1518== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==1518== Command: ./a.out
==1518== 
==1518== Invalid free() / delete / delete[] / realloc()
==1518==    at 0x402E358: free (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so)
==1518==    by 0x8048479: foo (doublefree.c:9)
==1518==    by 0x80484A5: main (doublefree.c:14)
==1518==  Address 0x41f9068 is 0 bytes inside a block of size 16 free'd
==1518==    at 0x402E358: free (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so)
==1518==    by 0x804846B: foo (doublefree.c:8)
==1518==    by 0x80484A5: main (doublefree.c:14)
==1518==  Block was alloc'd at
==1518==    at 0x402D17C: malloc (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so)
==1518==    by 0x804844A: foo (doublefree.c:6)
==1518==    by 0x80484A5: main (doublefree.c:14)
==1518== 
==1518== 
==1518== HEAP SUMMARY:
==1518==     in use at exit: 48 bytes in 2 blocks
==1518==   total heap usage: 3 allocs, 2 frees, 64 bytes allocated
==1518== 
==1518== 16 bytes in 1 blocks are definitely lost in loss record 1 of 2
==1518==    at 0x402D17C: malloc (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so)
==1518==    by 0x804849A: main (doublefree.c:13)
==1518== 
==1518== 32 bytes in 1 blocks are definitely lost in loss record 2 of 2
==1518==    at 0x402D17C: malloc (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so)
==1518==    by 0x804845A: foo (doublefree.c:7)
==1518==    by 0x80484A5: main (doublefree.c:14)
==1518== 
==1518== LEAK SUMMARY:
==1518==    definitely lost: 48 bytes in 2 blocks
==1518==    indirectly lost: 0 bytes in 0 blocks
==1518==      possibly lost: 0 bytes in 0 blocks
==1518==    still reachable: 0 bytes in 0 blocks
==1518==         suppressed: 0 bytes in 0 blocks
==1518== 
==1518== For counts of detected and suppressed errors, rerun with: -v
==1518== ERROR SUMMARY: 3 errors from 3 contexts (suppressed: 0 from 0)

The program should be executed as:

$ LD_PRELOAD=$PWD/check_leak.so ./a.out

where check_leak.so is the dynamic library of your version of malloc/free/realloc/calloc 
and a.out is the program that you are instrumenting/intercepting the real malloc/free/realloc/calloc calls.

Here is the article on how to intercept library function calls with your own version:
https://rafalcieslak.wordpress.com/2013/04/02/dynamic-linker-tricks-using-ld_preload-to-cheat-inject-features-and-investigate-programs/

The intercepting functions are already provided in the file check_leak.c in check_leak.tar .

<a href="https://www.engr.scu.edu/~slam3/coen225/check_leak.tar">
https://www.engr.scu.edu/~slam3/coen225/check_leak.tar
</a>

Unpacking check_leak.tar will create a directory called check_leak in your current directory. 
Change directory into check_leak and read the code in check_leak.c, which has the starter code for this homework.
The starter code intercepts malloc(), free(), realloc(), and calloc() and calls the real versions via the dynamic linker:

static void* (*real_malloc)(size_t) = NULL;
real_malloc = dlsym(RTLD_NEXT, "malloc");

A static function pointer is used here for optimization, to call dlsym() only once.

The starter code also has the logic to prevent being recursively called.
Some of the libc functions, such as printf() calls malloc().
If the intercepting version of malloc() calls printf, which calls malloc(), this would lead to infinite recursion.
To avoid infinite recursion,the starter code does a check to see if it is the first time on the runtime stack.
If so, do the intercepting logic, where you would add your leak detection logic here.
If not, call the real malloc/free/realloc/calloc directly.

To try out the starter code, do:

$ make 

to create check_leak.so .
The command line to compile check_leak.c is in the Makefile:

$ gcc -g -shared -fPIC check_leak.c -o check_leak.so -ldl

Then compile the 5 tests to a.out 

$ gcc -g test1.c

and run a.out using the intercepting library

$ LD_PRELOAD=$PWD/check_leak.so ./a.out

Read the code in check_leak.c to understand it before modifying it into what you need for this homework.
You can add but do not remove any of the following 7 functions.

The file check_leak.c has the following functions:

void* malloc(size_t size)                     intercepting function for the real malloc()
void free(void *p)                            intercepting function for the real free()
void *realloc( void *ptr, size_t new_size )   intercepting function for the real realloc()
void *calloc( size_t num, size_t size )       intercepting function for the real calloc()
-these functions are used to intercept the real heap functions, for you to add code to track
the actual heap memory chunks.

void __attribute__ ((destructor)) premain()   function called before main()
void __attribute__ ((destructor)) postmain()  function called after main()
-these two are used to initialize the check_leak data structure in the beginning,
and to print out the summary before program exit.

void generate_stack_trace (char* tmpfile, char* backtracestr)
-the function that generates the stack trace at the point of the call, into tmpfile,
and places the trace in the parameter backtracestr.

To get 10% extra credit, a stack trace will accompany the memory leaks and invalid frees
in the summary report.

Read the code in generate_stack_trace() to see how to print the backtrace to a file.
https://www.gnu.org/software/libc/manual/html_node/Backtraces.html
https://man7.org/linux/man-pages/man3/backtrace.3.html#NOTES

Uncomment the call to generate_stack_trace() in free() to observe the stack trace,
AFTER you run the program WITH the comment.
The trace looks like this:

/home/user/Mini-Valgrind/my_malloc.so(print_trace+0x84)[0xb7fd1af1]
/home/user/Mini-Valgrind/my_malloc.so(malloc+0xaa)[0xb7fd1c82]
./a.out[0x804845b]
./a.out[0x80484a6]
/lib/i386-linux-gnu/libc.so.6(__libc_start_main+0xf7)[0xb7e2b637]
./a.out[0x8048361]

You should trim the trace so the top line is one of malloc/free/realloc/calloc
and the bottom line should stop at __libc_start_main .

Notice the stack trace does not show the function names, and line numbers and is acceptable.

To show the function names, and line numbers, you can use gdb .
Given the stack trace line 

./a.out[0x80484a6] 

extract the file name a.out and offset 0x80484a6 and pass to gdb:

$ gdb -batch -ex "file a.out" -ex "info line * 0x80484a6"

Line 14 of "doublefree.c" starts at address 0x80484a1 <main+33> and ends at 0x80484ab <main+43>.

Since the function generate_stack_trace() generated the trace in the file /tmp/backtrace.txt ,
you can parse the file /tmp/backtrace.txt to get the file name and offset you need to pass to gdb.

You can call system as:

system("gdb -batch -ex 'file a.out' -ex 'info line * 0x80484a6' &gt; /tmp/backtrace.gdbout");

to generate the file name and line number into the file /tmp/backtrace.gdbout .
You would then open and read /tmp/backtrace.gdbout to get the the file names and line numbers.

Also notice the offset gives you one line off because stack trace gives the return address,
the address of the instruction after the call.

You can fix this by subtracting 1 from the start of the current line.

For example,

Given: ./a.out[0x80484a6]

$ gdb -batch -ex "file a.out" -ex "info line * 0x80484a6"
Line 14 of "doublefree.c" starts at address 0x80484a1 <main+33> and ends at 0x80484ab <main+43>.

***Line 14 is the line after the call.  To get the line of the call, replace 0x80484a6 by 0x80484a0.

$ gdb -batch -ex "file a.out" -ex "info line * 0x80484a0"
Line 13 of "doublefree.c" starts at address 0x804849a <main+33> and ends at 0x80484a0 <main+43>.

When finished, write comment in a file named README describing the important points of the implementation. 
Go up one directory from the working directory check_leak and pack the whole directory in a tar file:

$ tar cvf ./check_leak.tar ./check_leak

Then email the file check_leak.tar to slam3@scu.edu
Email subject should have: hw4 solution from <your name="">
</your></main+43></main+33></main+43></main+33></main+43></main+33></stdio.h></stdlib.h></stdio.h></pre></body></html>