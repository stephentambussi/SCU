/*  
*   Stephen Tambussi
*   COEN225
*   Lecture 5
*   10/18/22
*/
#include <stdio.h>
#include <string.h>

struct customer {
    char name[16];
    char creditcard[16];
};

// Use after free example
int main(void)
{
    struct customer *cptr;
    char cmd[16];
    do
    {
        puts("1. enter credit card info");
        puts("2. buy parking ticket");
        puts("3. done");
        gets(cmd);
        if(strcmp(cmd, "1")==0)
        {
            cptr = (struct customer *)calloc(1, sizeof(struct customer));
            puts("Enter name:");
            gets(cptr->name);
            puts("Enter credit card:");
            gets(cptr->creditcard);
        }
        else if(strcmp(cmd, "2")==0)
        {
            /*  The cptr value is not being changed in the done step so even after 
                freeing the struct it still points to the freed block of memory. 
                Therefore, a new user can skip entering their credit card info and 
                go straight to using the previous user's card info.
            */
            printf("Charged $10 to credit card:%s\n", cptr->creditcard);
        }
        else if(strcmp(cmd, "3")==0)
        {
            puts("Buy session done!");
            free(cptr); //struct is being freed but ...
            puts("New session...");
        }
        else
        {
            break;
        }
    } while (1);
}

/*
*   Garbage Collection
*   --------------------------------------------------------------
*   Reference counting: storing the number of references, pointers
*                       or handles to a resource such as an object,
*                       block of memory, disk space, etc.
*       - Need to do explicit programming to use it in C
*   
*   Garbage Collection Algorithms
*   1) Mark and Sweep
*       - Issue: leads to a lot of fragmentation
*       Data layout:
*           root_set[root, head]
*                     |       | 
*           ----------|-------|---------------------------------------------------------------
*           .......[@data@]..[data@]->[data@]->[data@].[garbage]..............................
*           ......../...\.....................................................................
*           .[@data@]..[@data@]...............................................................
*           ............/....\................................................................
*           .......[@data@]..[@data@].........................................................
*           ......../....\....................................................................
*           ..[@data@]..[@data@]..[garbage]...................................................
*           ..................................................................................
*           ----------------------------------------------------------------------------------
*       Algorithm:
*           for chunk in all heap chunks
*               chunk.mark_bit=0
*
*           for root_instance in root_set
*               traverse(root_instance)
*
*           void traverse(node)
*               mark(node)
*               for all p in pointer_set in node
*                   traverse(p)
*   2) Stop and Copy
*       - Divides the heap into 2 semi-spaces. When one semi-space is full, gc is invoked.
*       Data layout:
*           root_set[root, head]
*                     |       |         current_space                    new_space
*           ----------|-------|-------------------------------------------------------------------------------------
*           .......[.chk1.]..[chk2.]->[chk3.]->[chk4.].[garbage].|..................................................
*           ......../...\........................................|..................................................
*           .[.chk5.]..[.chk6.]..................................|..................................................
*           ........\.../........................................|..................................................
*           .......[.chk7.]..[.chk8.]............................|..................................................
*           .....................................................|..................................................
*           ..[.chk9.]..[.chk10]..[garbage]......................|..................................................
*           .....................................................|..................................................
*           --------------------------------------------------------------------------------------------------------
*       Algorithm:
*           free = &new_space
*           copy(*root_set,&free)
*           scan = new_space
*           while (scan < free)
*           {  
*               if (IS_POINTER(scan))
*                   copy(scan,&free)
*               scan++;
*           }
*           swap(Â¤t_space,&new_space)
*       Visualized Algorithm:
*                                                               free 
*                                                                 v
*           ----------|-------|-------------------------------------------------------------------------------------
*           .......[.chk1.]..[chk2.]->[chk3.]->[chk4.].[garbage].|..................................................
*           ......../...\........................................|..................................................
*           .[.chk5.]..[.chk6.]..................................|..................................................
*           ........\.../........................................|..................................................
*           .......[.chk7.]..[.chk8.]............................|..................................................
*           .....................................................|..................................................
*           ..[.chk9.]..[.chk10]..[garbage]......................|..................................................
*           .....................................................|..................................................
*           --------------------------------------------------------------------------------------------------------
*
*                                                               scan                         free 
*                                                                 v                            v
*           ----------|-------|-------------------------------------------------------------------------------------
*           .......[.chk1.]..[chk2.]->[chk3.]->[chk4.].[garbage].|[data,&chk5,&chk6][data,&chk3]....................
*           ......../...\........................................|..................................................
*           .[.chk5.]..[.chk6.]..................................|..................................................
*           ........\.../........................................|..................................................
*           .......[.chk7.]..[.chk8.]............................|..................................................
*           .....................................................|..................................................
*           ..[.chk9.]..[.chk10]..[garbage]......................|..................................................
*           .....................................................|..................................................
*           --------------------------------------------------------------------------------------------------------
*
*                                                                           scan                         free 
*                                                                             v                            v
*           ----------|-------|-------------------------------------------------------------------------------------
*           .......[.chk1.]..[chk2.]->[chk3.]->[chk4.].[garbage].|[data,&chk5,&chk6][data,&chk3][data,&chk7]........
*           ......../...\........................................|..................................................
*           .[.chk5.]..[.chk6.]..................................|..................................................
*           ........\.../........................................|..................................................
*           .......[.chk7.]..[.chk8.]............................|..................................................
*           .....................................................|..................................................
*           ..[.chk9.]..[.chk10]..[garbage]......................|..................................................
*           .....................................................|..................................................
*           --------------------------------------------------------------------------------------------------------
*
*                                                                                 scan                               free 
*                                                                                   v                                  v
*           ----------|-------|-------------------------------------------------------------------------------------
*           .......[.chk1.]..[chk2.]->[chk3.]->[chk4.].[garbage].|[data,&chk5,&chk6][data,&chk3][data,&chk7][data,&chk7]
*           ......../...\........................................|..................................................
*           .[.chk5.]..[.chk6.]..................................|..................................................
*           ........\.../........................................|..................................................
*           .......[.chk7.]..[.chk8.]............................|..................................................
*           .....................................................|..................................................
*           ..[.chk9.]..[.chk10]..[garbage]......................|..................................................
*           .....................................................|..................................................
*           --------------------------------------------------------------------------------------------------------
*
*   C++ Conservative Garbage Collection
*   - Challenges:
*       - int x = 0x0804b000; void *ptr = 0x0804b000; //which of x,ptr is a real pointer?
*   - In other languages, data tagging is used to distinguish between pointer type and integers
*       Lisp uses first 2 bits to tag/identify data types:
*           integer [00<----30bits---->] 
*           pointer [01<----30bits---->] 
*           float   [10<----30bits---->] 
*           unused  [11<----30bits---->] 
*   
*   Heap Exploits
*   --------------------------------------------------------------
*   1) Heap Unlink Exploit --> no longer working (it was patched)
*   2) Use after Free Exploit
*       - Based on exposing private information --> check above code to see exploit in action
*
*   Heap Exploits Assist
*   1) Heap Spray - writing to the heap of a running program
*       - Javascript: NOP sled + shell code
*       - C/C++: virtual pointers
*   2) Heap Feng Shui (heap grooming)
*       - Attempts to manipulate the layout of the heap by making
*         heap allocations of carefully selected sizes.                             
*/